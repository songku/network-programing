# advanced-network-programming
Advanced network programming programs

undefined reference to __imp_WSAStartup 等等等等的报错解决：
`g++ tcp.cpp -lwsock32 -o tcp.exe`

# 流式套接字编程
回射程序应该是用户控制结束，比如输入一个q或者ctrl z。在此之前，客户端与服务器一直保持连接，循环接收。

客户端一个send，一个recv，而recv中是循环读取接受的一个字节，判断是不是\n,不是的话接着循环接收。直到接收到的里面有\n，则退出接收。

recvline和recvn以及recvvl课堂上都有代码。

服务器端只需要一个recv_data[BUFFSIZE]的空间，不要多，必然可能出错。客户端发一个回车，实际上也是数据，recv()返回值>0，当且仅当客户端shutdown，rec=0，意识到客户端关闭连接。

注意回车换行符也算是一个字节内容。所以统计接收到的字节数目时，会加上这个值。

关于recvn和recvvl，其实都是封装函数，把数据完整接收到缓冲区。
对于recvvl，客户端事先发送长度，依旧是只发送数据，只是通过运算，将长度字段计算，放在数据的前四位。服务器端，根据这个数据的前四位，定长地去处理后面的数据。

## recvn
客户端强制提示客户，输入5个字符。否则重新输入。

服务器端fixedlen=5,接收到客户端五个字符，发送给客户端。

客户端fixedlen=10，不同于服务器端，从而能多接收到ECHO:这五个字节。

## recvvl
参考：[流式套接字网络程序](https://wenku.baidu.com/view/27d92a41f12d2af90242e672?pcf=2&bfetype=new&bfetype=new)
变长接收功能设计与实现
  实现变长接收功能的函数有char* Recvvl()和 void DoRecvvl(),功能设计上与定长相似，
  前者完成的是一次变长接收过程，后者通过循环调用前者实现循环多次变长接收。接下来将分别介绍
	char* Recvvl():该函数的设计思路为：两次定长接收过程，第一次接收4字节的数据长度说明头部，第二次根据接收到的长度，定长接收后续数据。实现的伪代码如下：
```
  char * Tcpserver: Recvvl{
  定长接收4字节头部长度至1en;
  定长接收1en字节数据长度
  成功则返回收到的数据，否则返回NULL}
```
  
变长发送功能设计与实现
实现变长发送功能的函数为：char* Sendvl(),该函数将待发送数据的长度以四字节的宽度重组在数据的前面，发给服务器。实现的伪代码如下:
```
char *Tcpclient: Sendvl(){
	int clen=0;//数据长度
	char info[BUF_SIZE];//组装后的数据
	//在服务器与客户端之间发送和接收数据
	while(true)
	{
		接收控制台输入数据;
		计算数据长度给clen;
		将长度以四字节宽度组装数据前面至info;
		发送info给服务器;
		接收并打印服务器回传的数据
	}
	return buf;
}
```
## 计算程序设计
客户端发送带空格的两个数。服务器端recv接收后，将缓冲区字符数组拼接为字符串，通过字符串操作提取两个加数。求和。并利用sprintf(buffer,”%d”,number);将int转为字符数组。之后包装长度数据，发送长度数据给客户端，在发送实际数据给客户端。客户端通过recvvl()成功接收。
# 数据报套接字编程
## 并发服务器实现
并发服务器实现，其实是服务器端采用一个已知的端口，去阻塞接收来自客户端发送的数据。接收后，传递主线程接收到的连接参数，并拷贝echo数据到参数内，调用创建子线程函数。在新的子线程内，绑定的端口是一个全局变量dynamiic_port,也即htonl，每个子线程都使用不同的端口。而客户端第一次接收数据后，即从sockaddr参数中获取这个新的服务器端子线程的端口，并在之后的sendto中，与这个端口交互。
## UDP丢包统计
详见博客[无连接应用程序丢包率测试/UDP丢包率测试【基于数据报套接字的网络程序设计】](https://blog.csdn.net/qq_41581354/article/details/121644050)

## P2P打洞聊天程序
需要使用`-lws2_32`
